<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>tamayoke2</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
<style>
  html,body{height:100%;margin:0;background:#070b16;color:#fff;font-family:"Noto Sans JP",sans-serif;}
  #stage{position:relative;height:100vh;display:flex;align-items:center;justify-content:center;}
  canvas#g{image-rendering:pixelated;box-shadow:0 0 0 1px #223;}
  .leaderboard{
    position:absolute;top:12px;right:12px;width:260px;height:240px;padding:8px;
    border:1px solid #334;background:rgba(0,0,0,.35);
    font:14px "Orbitron",monospace;white-space:pre;overflow:auto;color:#fff;
  }
  .brand{position:fixed;left:12px;bottom:12px;font:12px monospace;color:#9cf;}
  .boot{position:fixed;left:12px;top:12px;background:rgba(0,0,0,.45);border:1px solid #334;
        padding:6px 8px;font:12px/1.4 monospace;color:#9cf;max-width:48vw;white-space:pre-wrap}
</style>
</head>
<body>
  <div id="stage">
    <canvas id="g" width="960" height="540"></canvas>
    <pre id="ui-leaderboard" class="leaderboard">未設定</pre>
  </div>
  <div class="brand">tamayoke2</div>
  <pre id="bootlog" class="boot">boot…</pre>

<script>
/* ==========================================================
   tamayoke2 — assets/img + assets/audio 対応単一ファイル版
   ・今回の修正：
     - セーフゾーン画像は等倍スケールでタイル（縦横比保持）
     - ボーナス半径を 96 に拡大
     - 通常弾（白）を減速（vy 90〜120）
     - 360度ばら撒き（リング）を完全廃止
   ========================================================== */

// ★キャッシュ破り（毎回変えてください）
const V = "fix-safe-aspect-bonus-big-slow-normal-20250825-1";

// ★あなたの GAS /exec（直指定）
const RANK_ENDPOINT = "https://script.google.com/macros/s/AKfycbxvQ-miSQfyYy2fEmeNstkb-WiHMtTeuJjl2KzuklxYc1UOeytF6F-O1KX1waNZ8QUO2w/exec";

// 画像パス（存在しなくてもOK：無ければフォールバック）
const IMG_SRC = {
  bg:         "assets/img/bg_mechcity_loop.png",
  zoneSafe:   "assets/img/zone_safe.png",
  zoneBonus:  "assets/img/zone_bonus.png",
  player:     "assets/img/player.png",
  b_normal:   "assets/img/bullet_normal.png",
  b_fast:     "assets/img/bullet_fast.png",
  b_homing:   "assets/img/bullet_homing.png",
  b_big:      "assets/img/bullet_big.png",
};
// BGM（実ファイル）
const BGM_SRC = {
  title:  "assets/audio/bgm_title.mp3",
  play:   "assets/audio/bgm_stage1.mp3",
  result: "assets/audio/bgm_result.mp3",
};

// ---- 便利ログ（左上） ----
const blog = document.getElementById("bootlog");
function bl(msg){ blog.textContent += "\n" + msg; }

// ---- util ----
const bust = (url)=> url + (url.includes("?")?"&":"?") + "v=" + encodeURIComponent(V);

window.addEventListener("DOMContentLoaded", () => boot().catch(e=>{bl("BOOT ERROR: "+e.message); console.error(e);} ));

async function boot(){
  bl("V="+V);

  // ---------- Canvas ----------
  const canvas = document.getElementById("g");
  if(!canvas) throw new Error("#g canvas not found");
  const ctx = canvas.getContext("2d");
  const W=canvas.width, H=canvas.height;
  function fit(){ const s=Math.min(innerWidth/W, innerHeight/H); canvas.style.width=`${(W*s)|0}px`; canvas.style.height=`${(H*s)|0}px`; }
  addEventListener("resize",fit); fit();

  // ---------- 画像ローダ（?v= でキャッシュ破り） ----------
  const IMG = new Map();
  async function loadImage(url){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=bust(url); }); }
  async function tryLoad(key,url){ try{ const img=await loadImage(url); IMG.set(key,img); bl("img ok: "+url); }catch{ bl("img miss: "+url); } }
  await Promise.all(Object.entries(IMG_SRC).map(([k,u])=>tryLoad(k,u)));

  // ---------- ランキング ----------
  const elLB = document.getElementById("ui-leaderboard");
  class Rank {
    constructor(endpoint){ this.endpoint=String(endpoint||"").trim(); this.enabled=!!this.endpoint; }
    async top(){ if(!this.enabled) return {status:"disabled",rows:[]};
      const r=await fetch(bust(this.endpoint+"?action=top"),{cache:"no-store"}); if(!r.ok) throw new Error("HTTP "+r.status);
      const arr=await r.json(); return {status:"ok",rows:Array.isArray(arr)?arr:[]}; }
    async submit(name, score){
      if(!this.enabled) return {status:"disabled"};
      const body=new URLSearchParams({name:String(name||"YOU").slice(0,16),score:String(Math.max(0,score|0)),_ua:navigator.userAgent.slice(0,64)});
      const r=await fetch(bust(this.endpoint),{method:"POST",body}); if(!r.ok) return {status:"error",error:"HTTP "+r.status};
      const d=await r.json().catch(()=>({})); return d&&d.ok?{status:"ok"}:{status:"error",error:d?.error||"unknown"};
    }
  }
  const rank = new Rank(RANK_ENDPOINT);
  async function renderLeaderboard(){
    if(!elLB) return;
    if(!rank.enabled){ elLB.textContent="未設定"; return; }
    elLB.textContent="LOADING...";
    try{
      const {status,rows}=await rank.top();
      if(status!=="ok"){ elLB.textContent="通信エラー"; return; }
      const lines=(rows||[]).slice(0,10).map((r,i)=>{
        const no=String(i+1).padStart(2,"0");
        const name=String(r.name||"").slice(0,10).padEnd(10," ");
        const sc=String(Number(r.score)||0).padStart(6," ");
        return `${no}. ${name}  ${sc}`;
      });
      elLB.textContent=lines.length?lines.join("\n"):"まだスコアがありません";
    }catch(e){ console.error(e); elLB.textContent="通信エラー"; }
  }
  if(rank.enabled){ bl("endpoint="+rank.endpoint); await renderLeaderboard(); } else { bl("endpoint=(empty) → 未設定"); }

  // ---------- Audio ----------
  let AC=null, master=null, unlocked=false;
  function makeAC(){ AC=new (window.AudioContext||window.webkitAudioContext)(); master=AC.createGain(); master.connect(AC.destination); master.gain.value=0.9; }
  async function unlockAudio(){ if(unlocked) return; if(!AC) makeAC(); try{ await AC.resume(); unlocked=(AC.state==="running"); }catch{} }

  // BGMデコーダ
  const ABUF = new Map();
  async function decodeAudio(key, url){
    try{
      if(!AC) makeAC();
      const r = await fetch(bust(url)); const array = await r.arrayBuffer();
      const buf = await AC.decodeAudioData(array);
      ABUF.set(key, buf); bl("bgm ok: "+url);
    }catch(e){ bl("bgm miss: "+url); }
  }
  await Promise.all(Object.entries(BGM_SRC).map(([k,u])=>decodeAudio(k,u)));

  // BGMプレイヤ（2chクロスフェード）
  class BGM {
    constructor(){ this.g1=AC.createGain(); this.g2=AC.createGain(); this.g1.connect(master); this.g2.connect(master); this.s1=this.s2=null; this.which=0; this.g1.gain.value=this.g2.gain.value=0; }
    _startOn(g,buf){ const s=AC.createBufferSource(); s.buffer=buf; s.loop=true; s.connect(g); s.start(); return s; }
    play(name, ms=400){
      const buf=ABUF.get(name);
      if(!buf){ padCrossTo(name==="play"?"play":"title", ms); return; }
      const now=AC.currentTime, dur=Math.max(0.01, ms/1000);
      if(this.which===0){ if(this.s2){try{this.s2.stop()}catch{} this.s2=null;} if(this.s1){try{this.s1.stop()}catch{} } this.s1=this._startOn(this.g1,buf);
        this.g1.gain.setValueAtTime(this.g1.gain.value, now); this.g1.gain.linearRampToValueAtTime(0.6, now+dur);
        this.g2.gain.setValueAtTime(this.g2.gain.value, now); this.g2.gain.linearRampToValueAtTime(0.0, now+dur); this.which=1;
      }else{ if(this.s1){try{this.s1.stop()}catch{} this.s1=null;} if(this.s2){try{this.s2.stop()}catch{} } this.s2=this._startOn(this.g2,buf);
        this.g2.gain.setValueAtTime(this.g2.gain.value, now); this.g2.gain.linearRampToValueAtTime(0.6, now+dur);
        this.g1.gain.setValueAtTime(this.g1.gain.value, now); this.g1.gain.linearRampToValueAtTime(0.0, now+dur); this.which=0; }
    }
    stop(){ try{this.s1?.stop()}catch{} try{this.s2?.stop()}catch{} this.s1=this.s2=null; this.g1.gain.value=this.g2.gain.value=0; }
  }

  // パッドBGM（フォールバック）
  const pads = { title:{osc:null,gain:null,f:220,lfoF:0.2}, play:{osc:null,gain:null,f:330,lfoF:0.4} };
  function padStart(which){
    if(!AC) return; const p=pads[which]; if(!p||p.osc) return;
    const o=AC.createOscillator(); o.type="sawtooth"; o.frequency.value=p.f;
    const g=AC.createGain(); g.gain.value=0;
    const lfo=AC.createOscillator(); const lfoG=AC.createGain(); lfo.frequency.value=p.lfoF; lfoG.gain.value=30; lfo.connect(lfoG).connect(o.frequency);
    o.connect(g).connect(master); o.start(); lfo.start(); p.osc=o; p.gain=g; p._lfo=lfo; p._lfoG=lfoG;
  }
  function padStop(which){ const p=pads[which]; if(!p||!p.osc) return; try{p.osc.stop();p._lfo.stop();}catch{} p.osc.disconnect();p.gain.disconnect();p._lfo.disconnect();p._lfoG.disconnect(); p.osc=p.gain=p._lfo=p._lfoG=null; }
  function padCrossTo(which,ms=400){
    if(!AC) return; const now=AC.currentTime, dur=Math.max(0.01,ms/1000);
    for(const k of Object.keys(pads)){ const p=pads[k]; padStart(k); const tgt=(k===which)?0.5:0.0; p.gain.gain.setValueAtTime(p.gain.gain.value,now); p.gain.gain.linearRampToValueAtTime(tgt,now+dur); if(k!==which) setTimeout(()=>padStop(k),ms+60); }
  }
  // 効果音
  function beep(hz=880,ms=120,vol=0.25){ if(!AC) return; const o=AC.createOscillator(); o.type="square"; o.frequency.value=hz; const g=AC.createGain(); g.gain.value=vol; o.connect(g).connect(master); o.start(); const now=AC.currentTime; g.gain.setValueAtTime(vol,now); g.gain.linearRampToValueAtTime(0,now+ms/1000); setTimeout(()=>{try{o.stop()}catch{}},ms+20); }
  function thud(){ if(!AC) return; const o=AC.createOscillator(); o.type="triangle"; const g=AC.createGain(); o.connect(g).connect(master); const now=AC.currentTime; o.frequency.setValueAtTime(200,now); o.frequency.exponentialRampToValueAtTime(60,now+0.2); g.gain.setValueAtTime(0.5,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.25); o.start(); setTimeout(()=>{try{o.stop()}catch{}},260); }

  const bgm = new BGM();

  // ---------- ゾーン ----------
  const SAFE_H = 90; // 下部セーフ高さ
  const bonus = { cx:480, cy:243, rOrbit:70, radius:96, speed:0.6 }; // ← 半径を大きく

  function drawZones(t){
    // セーフ（等倍スケールでタイル＝縦横比保持）
    const texSafe=IMG.get("zoneSafe");
    if(texSafe){
      const y=H-SAFE_H;
      const scale = SAFE_H / texSafe.height;             // 高さ合わせ（縦横比保持）
      const wScaled = texSafe.width * scale;
      ctx.globalAlpha=0.95;
      for(let x=0; x<W+1; x+=wScaled){
        ctx.drawImage(texSafe, x, y, wScaled, SAFE_H);
      }
      ctx.globalAlpha=1;
    }else{
      ctx.fillStyle="rgba(20,200,120,0.10)"; ctx.fillRect(0,H-SAFE_H,W,SAFE_H);
    }

    // ボーナス（大きめ）
    const ang=t*bonus.speed, bx=bonus.cx+Math.cos(ang)*bonus.rOrbit, by=bonus.cy+Math.sin(ang)*bonus.rOrbit;
    const texB=IMG.get("zoneBonus");
    if(texB){
      ctx.save(); ctx.translate(bx,by);
      ctx.globalAlpha=0.95;
      ctx.drawImage(texB, -bonus.radius, -bonus.radius, bonus.radius*2, bonus.radius*2);
      ctx.globalAlpha=1;
      ctx.restore();
      ctx.strokeStyle="rgba(250,210,60,0.25)"; ctx.beginPath(); ctx.arc(bonus.cx,bonus.cy,bonus.rOrbit,0,Math.PI*2); ctx.stroke();
    }else{
      ctx.fillStyle="rgba(250,210,60,0.12)";
      ctx.beginPath(); ctx.arc(bx,by,bonus.radius,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(250,210,60,0.25)"; ctx.beginPath(); ctx.arc(bonus.cx,bonus.cy,bonus.rOrbit,0,Math.PI*2); ctx.stroke();
    }
    return {bx,by};
  }
  function inCircle(px,py,cx,cy,r){ const dx=px-cx, dy=py-cy; return dx*dx+dy*dy <= r*r; }

  // ---------- 背景 ----------
  const stars = [{n:60, sp:10, pts:[]},{n:40, sp:20, pts:[]},{n:20, sp:35, pts:[]},];
  for(const layer of stars){ for(let i=0;i<layer.n;i++) layer.pts.push({x:Math.random()*W, y:Math.random()*H}); }
  function drawBG(t){
    const bg=IMG.get("bg");
    if(bg){ const y=(t*40)%H; ctx.drawImage(bg,0,y-H,W,H); ctx.drawImage(bg,0,y,W,H); }
    else { const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,"#0b1020"); g.addColorStop(1,"#0f1830"); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      ctx.fillStyle="rgba(255,255,255,0.6)"; for(const layer of stars){ for(const p of layer.pts){ p.y += layer.sp*0.016; if(p.y>H) p.y-=H; ctx.fillRect(p.x, p.y, 1.2, 1.2);} } }
  }

  // ---------- ゲーム状態 ----------
  const TITLE="title", PLAY="play", OVER="over";
  const player={ x:W/2, y:H*0.8, size:26, hitR:10, speed:245, slow:0.5, vx:0, vy:0 };
  let bullets=[], state=TITLE, allowReturnAt=0, timePlay=0, score=0;

  // ---------- 弾（リング完全廃止） ----------
  const timers={ rain:0, side:0, homing:0, kanji:0 }; // ← ring を削除
  function randomKanji(){ const s="炎雷風水土空光闇心愛夢星竜鬼斬破護爆迅煌零冥極華刹翔滅砲砕烈煌舞刃閃虎龍雷火光影彗".split(""); return s[(Math.random()*s.length)|0]; }

  function spawn(dt){
    timers.rain+=dt; timers.side+=dt; timers.homing+=dt; timers.kanji+=dt;

    // 雨（白：遅く）
    if(timers.rain>=0.15){ timers.rain=0;
      const x=20+Math.random()*(W-40);
      bullets.push({kind:"normal",x,y:-10,vx:0,vy:90+Math.random()*30,r:6,alive:true}); // ← 90〜120 に減速
    }
    // 横（赤：fast）
    if(timers.side>=1.1){ timers.side=0;
      const L=Math.random()<0.5, y0=60+Math.random()*(H-220);
      for(let i=0;i<7;i++){
        bullets.push({kind:"fast",x:L?-10:W+10,y:y0+i*9,vx:L?160:-160,vy:(Math.random()*2-1)*22,r:5,alive:true});
      }
    }
    // 誘導（青）
    if(timers.homing>=3.6){ timers.homing=0;
      const edge=(Math.random()*4)|0; let x=0,y=0;
      if(edge===0){x=Math.random()*W;y=-10;} if(edge===1){x=W+10;y=Math.random()*H;}
      if(edge===2){x=Math.random()*W;y=H+10;} if(edge===3){x=-10;y=Math.random()*H;}
      const ang=Math.atan2(player.y-y, player.x-x), v=145;
      bullets.push({kind:"homing",x,y,vx:Math.cos(ang)*v,vy:Math.sin(ang)*v,turnDeg:120,r:6,alive:true,homing:true});
    }
    // 巨大（漢字風）弾
    if(timers.kanji>=5.0){ timers.kanji=0;
      const x=40+Math.random()*(W-80);
      bullets.push({kind:"big",x,y:-30,vx:0,vy:95,turnDeg:60,r:24,alive:true,text:randomKanji()});
    }
  }

  function update(dt){
    // プレイヤー移動
    let dx=0,dy=0;
    if(keys.has("ArrowLeft")||keys.has("a")||keys.has("A")) dx-=1;
    if(keys.has("ArrowRight")||keys.has("d")||keys.has("D")) dx+=1;
    if(keys.has("ArrowUp")||keys.has("w")||keys.has("W")) dy-=1;
    if(keys.has("ArrowDown")||keys.has("s")||keys.has("S")) dy+=1;
    if(pointerDown){ player.x+=(pointerX-player.x)*0.35; player.y+=(pointerY-player.y)*0.35; player.vx=(pointerX-player.x); player.vy=(pointerY-player.y); }
    else if(dx||dy){ const len=Math.hypot(dx,dy)||1; const v=player.speed*((keys.has("Shift")||keys.has(" "))?player.slow:1);
      const vx=(dx/len)*v, vy=(dy/len)*v; player.x+=vx*dt; player.y+=vy*dt; player.vx=vx; player.vy=vy; }
    player.x=Math.max(0,Math.min(W,player.x)); player.y=Math.max(0,Math.min(H,player.y));

    // 弾
    spawn(dt);
    for(const b of bullets){
      if(b.homing){
        const angTo=Math.atan2(player.y-b.y, player.x-b.x);
        const cur=Math.atan2(b.vy,b.vx);
        const max=(b.turnDeg*Math.PI/180)*dt;
        let diff=angTo-cur; while(diff>Math.PI) diff-=Math.PI*2; while(diff<-Math.PI) diff+=Math.PI*2;
        diff=Math.max(-max,Math.min(max,diff));
        const next=cur+diff; const sp=Math.hypot(b.vx,b.vy)||145;
        b.vx=Math.cos(next)*sp; b.vy=Math.sin(next)*sp;
      } else if (b.kind==="big"){
        const angTo=Math.atan2(player.y-b.y, player.x-b.x);
        const cur=Math.atan2(b.vy,b.vx);
        const max=(b.turnDeg*Math.PI/180)*dt;
        let diff=angTo-cur; while(diff>Math.PI) diff-=Math.PI*2; while(diff<-Math.PI) diff+=Math.PI*2;
        diff=Math.max(-max,Math.min(max,diff));
        const next=cur+diff; const sp=Math.hypot(b.vx,b.vy)||110;
        b.vx=Math.cos(next)*sp; b.vy=Math.sin(next)*sp;
      }
      b.x+=b.vx*dt; b.y+=b.vy*dt;
      if(b.x<-80||b.x>W+80||b.y<-80||b.y>H+80) b.alive=false;
    }
    bullets=bullets.filter(b=>b.alive);

    // 当たり
    for(const b of bullets){
      const rr=(b.r+player.hitR), dx=b.x-player.x, dy=b.y-player.y;
      if(dx*dx+dy*dy<=rr*rr) return true;
    }
    return false;
  }

  // ---------- 入力 ----------
  const keys=new Set(); let pointerDown=false, pointerX=W/2, pointerY=H*0.75;
  addEventListener("keydown",e=>{ if(!e.repeat) keys.add(e.key); if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault(); });
  addEventListener("keyup",e=>keys.delete(e.key));
  function cpos(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)*W/r.width, y:(e.clientY-r.top)*H/r.height}; }
  canvas.addEventListener("pointerdown",e=>{ pointerDown=true; const p=cpos(e); pointerX=p.x; pointerY=p.y; unlockAudio(); });
  addEventListener("pointerup",()=> pointerDown=false);
  canvas.addEventListener("pointermove",e=>{ if(!pointerDown) return; const p=cpos(e); pointerX=p.x; pointerY=p.y; });

  // ---------- 描画 ----------
  function drawPlayer(){
    const img=IMG.get("player"); const ang=Math.atan2(player.vy, player.vx)||0;
    ctx.save(); ctx.translate(player.x,player.y); ctx.rotate(ang); const s=player.size;
    if(img){ ctx.drawImage(img, -s, -s, s*2, s*2); }
    else { ctx.shadowColor="rgba(80,200,255,0.6)"; ctx.shadowBlur=20; ctx.fillStyle="#4cf"; ctx.beginPath(); ctx.moveTo(0,-s); ctx.lineTo(s*0.7,0); ctx.lineTo(0,s); ctx.lineTo(-s*0.7,0); ctx.closePath(); ctx.fill(); ctx.shadowBlur=0; ctx.strokeStyle="rgba(255,255,255,0.35)"; ctx.beginPath(); ctx.arc(0,0,player.hitR,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();
  }
  function drawBullets(){
    for(const b of bullets){
      if(b.kind==="normal"){ const sp=IMG.get("b_normal"); if(sp) ctx.drawImage(sp,b.x-b.r,b.y-b.r,b.r*2,b.r*2); else { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); } }
      else if(b.kind==="fast"){ const sp=IMG.get("b_fast"); if(sp) ctx.drawImage(sp,b.x-b.r,b.y-b.r,b.r*2,b.r*2); else { ctx.fillStyle="#f55"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); } }
      else if(b.kind==="homing"){ const sp=IMG.get("b_homing"); if(sp) ctx.drawImage(sp,b.x-b.r,b.y-b.r,b.r*2,b.r*2); else { ctx.fillStyle="#6cf"; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); } }
      else if(b.kind==="big"){
        const sp=IMG.get("b_big"); ctx.save(); ctx.translate(b.x,b.y);
        ctx.fillStyle="rgba(255,255,255,0.12)"; ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
        if(sp) ctx.drawImage(sp, -b.r, -b.r, b.r*2, b.r*2);
        ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.font="bold 20px Noto Sans JP, sans-serif"; ctx.fillText(b.text||"炎",0,2);
        ctx.fillStyle="#f55"; ctx.font="10px Noto Sans JP, sans-serif"; ctx.fillText("アツイ",0,-b.r+10);
        ctx.restore();
      }
    }
  }
  function drawTitle(){ ctx.fillStyle="#fff"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.font="64px Orbitron, sans-serif"; ctx.fillText("TAMAYOKE 2", W/2, H*0.33); ctx.font="18px Noto Sans JP, sans-serif"; ctx.fillText("クリック／Enter でスタート", W/2, H*0.33+56); }
  function drawGameOver(){ ctx.font="46px Orbitron, sans-serif"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillStyle="#ff9"; ctx.fillText("GAME OVER", W/2, H*0.35); ctx.font="18px Noto Sans JP, sans-serif"; ctx.fillStyle="#fff"; ctx.fillText("0.7秒後に クリック／Enter でタイトルへ", W/2, H*0.35+50); }
  function drawScore(){ const s=String(score|0).padStart(6,"0"); ctx.font="20px Orbitron, monospace"; ctx.textAlign="right"; ctx.textBaseline="top"; ctx.fillStyle="#fff"; ctx.fillText(`SCORE  ${s}`, W-16, 12); }

  // ---------- 送信（初回必ず・以降ベスト時） ----------
  const SUBMITTED_KEY="rankSubmittedOnce";
  const loadPlayerName = () => localStorage.getItem("playerName") || "";
  const savePlayerName = n => localStorage.setItem("playerName", String(n||"").slice(0,16));
  const loadBest = () => Number(localStorage.getItem("bestScore")||"0")|0;
  const saveBest = v => localStorage.setItem("bestScore", String(v|0));
  async function submitScore(finalScore){
    if(!rank.enabled) return;
    const already = localStorage.getItem(SUBMITTED_KEY)==="1";
    const best = loadBest();
    const mustSubmit = !already;
    const isBest = (finalScore|0) > best;
    if(!mustSubmit && !isBest) return;
    if(isBest) saveBest(finalScore|0);
    let name = loadPlayerName(); if(!name){ name=(prompt("名前（16文字まで）を入力してください","YOU")||"YOU").trim().slice(0,16); savePlayerName(name); }
    const prev=elLB.textContent; elLB.textContent="SUBMITTING...";
    const res=await rank.submit(name, finalScore|0);
    if(res.status==="ok"){ localStorage.setItem(SUBMITTED_KEY,"1"); await renderLeaderboard(); beep(1320,120,0.35); }
    else { console.error(res.error||"submit failed"); elLB.textContent=prev||"通信エラー"; }
  }

  // ---------- ループ ----------
  let prev=performance.now(), tAccum=0;
  bl("title ready");

  if(!AC) makeAC();
  if(ABUF.size){ bgm.play("title", 400); } else { padCrossTo("title", 400); }

  requestAnimationFrame(function loop(ts){
    const dt=Math.min(1/20, Math.max(0,(ts-prev)/1000)); prev=ts; tAccum+=dt;

    drawBG(tAccum);
    const {bx,by}=drawZones(tAccum);

    if(state===TITLE){
      drawTitle();
      if(keys.has("Enter")||pointerDown){ pointerDown=false; state=PLAY; timePlay=0; score=0; bullets.length=0; unlockAudio(); if(ABUF.size){ bgm.play("play", 400); } else { padCrossTo("play", 400); } }
    }else if(state===PLAY){
      timePlay+=dt; const bonusOn = inCircle(player.x,player.y,bx,by,bonus.radius);
      score += (bonusOn?4:1)*10*dt;
      if(update(dt)){ const fs=score|0; thud(); submitScore(fs).catch(()=>{}); state=OVER; allowReturnAt=performance.now()+700; bullets.length=0; if(ABUF.size){ bgm.play("result", 400);} else { padCrossTo("title", 400);} }
      drawBullets(); drawPlayer(); drawScore();
    }else{ // OVER
      drawBullets(); drawGameOver(); drawScore();
      if(performance.now()>=allowReturnAt && (keys.has("Enter")||pointerDown)){ pointerDown=false; state=TITLE; timePlay=0; if(ABUF.size){ bgm.play("title", 400); } else { padCrossTo("title", 400);} }
    }

    requestAnimationFrame(loop);
  });
}
</script>
</body>
</html>
